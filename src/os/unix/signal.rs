//! Signal support for Unix-like systems.
//!
//! Signals in Unix are much more functional and versatile than ANSI C signals â€” there is simply much, much more of them. In addition to that, there is a special group of signals called "real-time signals" (more on those below).
//!
//! # Main signals
//! The [`SignalType`] enumeration provides all standard signals as defined in POSIX.1-2001. More signal types may be added later, which is why exhaustively matching on it is not possible. It can be cheaply converted to a 32-bit integer, though. See its documentation for more on conversions.
//!
//! The `set_handler` function is used to create an association between a `SignalType` and a signal handling strategy.
//!
//! # Real-time signals
//! In addition to usual signals, there's a special group of signals called "real-time signals". Those signals do not have fixed identifiers and are not generated by the system or kernel. Instead, they can only be sent between processes.
//!
//! # Signal-safe system calls
//! Not all system calls can be called from a signal handler. Allocating memory, using the thread API and manipulating interval timers, for example, is prohibited in a signal handler. Any attempt to call a system call which is not signal safe results in undefined behavior, i.e. memory unsafety. Rather than excluding certain specific system calls, the POSIX specification only speicifies system calls which *are* signal-safe. The following C functions are guaranteed to be safe to call from a signal handler:
//! - `_Exit`
//! - `_exit`
//! - `abort`
//! - `accept`
//! - `access`
//! - `aio_error`
//! - `aio_return`
//! - `aio_suspend`
//! - `alarm`
//! - `bind`
//! - `cfgetispeed`
//! - `cfgetospeed`
//! - `cfsetispeed`
//! - `cfsetospeed`
//! - `chdir`
//! - `chmod`
//! - `chown`
//! - `clock_gettime`
//! - `close`
//! - `connect`
//! - `creat`
//! - `dup`
//! - `dup2`
//! - `execle`
//! - `execve`
//! - `fchmod`
//! - `fchown`
//! - `fcntl`
//! - `fdatasync`
//! - `fork`
//! - `fpathconf`
//! - `fstat`
//! - `fsync`
//! - `ftruncate`
//! - `getegid`
//! - `geteuid`
//! - `getgid`
//! - `getgroups`
//! - `getpeername`
//! - `getpgrp`
//! - `getpid`
//! - `getppid`
//! - `getsockname`
//! - `getsockopt`
//! - `getuid`
//! - `kill`
//! - `link`
//! - `listen`
//! - `lseek`
//! - `lstat`
//! - `mkdir`
//! - `mkfifo`
//! - `open`
//! - `pathconf`
//! - `pause`
//! - `pipe`
//! - `poll`
//! - `posix_trace_event`
//! - `pselect`
//! - `raise`
//! - `read`
//! - `readlink`
//! - `recv`
//! - `recvfrom`
//! - `recvmsg`
//! - `rename`
//! - `rmdir`
//! - `select`
//! - `sem_post`
//! - `send`
//! - `sendmsg`
//! - `sendto`
//! - `setgid`
//! - `setpgid`
//! - `setsid`
//! - `setsockopt`
//! - `setuid`
//! - `shutdown`
//! - `sigaction`
//! - `sigaddset`
//! - `sigdelset`
//! - `sigemptyset`
//! - `sigfillset`
//! - `sigismember`
//! - `signal`
//! - `sigpause`
//! - `sigpending`
//! - `sigprocmask`
//! - `sigqueue`
//! - `sigset`
//! - `sigsuspend`
//! - `sleep`
//! - `sockatmark`
//! - `socket`
//! - `socketpair`
//! - `stat`
//! - `symlink`
//! - `sysconf`
//! - `tcdrain`
//! - `tcflow`
//! - `tcflush`
//! - `tcgetattr`
//! - `tcgetpgrp`
//! - `tcsendbreak`
//! - `tcsetattr`
//! - `tcsetpgrp`
//! - `time`
//! - `timer_getoverrun`
//! - `timer_gettime`
//! - `timer_settime`
//! - `times`
//! - `umask`
//! - `uname`
//! - `unlink`
//! - `utime`
//! - `wait`
//! - `waitpid`
//! - `write`
//! 
//! Many safe Rust types can trigger signal-unsafe system calls not on this list, for example, `Vec`, `Box` and `Rc`/`Arc` perform memory allocations, while `Mutex`/`RwLock` perform `pthread` calls. For this reason, creating a signal hook is an unsafe operation.
//!
//! [`SignalType`]: enum.SignalType.html " "

#[cfg(unix)]
use libc::{
    SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGABRT, SIGFPE, SIGKILL, SIGSEGV, SIGPIPE, SIGALRM, SIGTERM,
    SIGUSR1, SIGUSR2, SIGCHLD, SIGCONT, SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU, SIGBUS, SIGPROF,
    SIGPOLL, SIGSYS, SIGTRAP, SIGURG, SIGVTALRM, SIGXCPU, SIGXFSZ,
    SIG_DFL,
    SA_NOCLDSTOP, SA_NODEFER, SA_RESETHAND, SA_RESTART,
    sigaction,
};
#[cfg(not(unix))]
macro_rules! fake_consts {
    ($($name:ident = $val:expr),+ $(,)?) => (
        $(
            #[cfg(not(unix))]
            const $name : i32 = $val;
        )+
    );
}
#[cfg(not(unix))]
fake_consts! {
    SIGHUP = 0, SIGINT = 1, SIGQUIT = 2, SIGILL = 3, SIGABRT = 4, SIGFPE = 5, SIGKILL = 6,
    SIGSEGV = 7, SIGPIPE = 8, SIGALRM = 9, SIGTERM = 10, SIGUSR1 = 11, SIGUSR2 = 12, SIGCHLD = 13,
    SIGCONT = 14, SIGSTOP = 15, SIGTSTP = 16, SIGTTIN = 17, SIGTTOU = 18, SIGBUS = 19,
    SIGPROF = 20, SIGPOLL = 21, SIGSYS = 22, SIGTRAP = 23, SIGURG = 24, SIGVTALRM = 25,
    SIGXCPU = 26, SIGXFSZ = 27,
}
use std::{
    io::{self, prelude::*},
    fmt::{self, Formatter, Display},
    error::Error,
    convert::TryFrom,
    mem::{self, zeroed},
    panic, process, thread,
    any::Any,
};
#[cfg(unix)]
use spin::RwLock;
#[cfg(unix)]
use intmap::IntMap;
#[cfg(unix)]
use thiserror::Error;
#[cfg(unix)]
use cfg_if::cfg_if;
#[cfg(unix)]
use lazy_static::lazy_static;
#[cfg(unix)]
cfg_if! {
    if #[cfg(any(
        target_os = "linux",
        target_os = "android",
    ))] {
        // don't care about LinuxThreads lmao
        const SIGRTMIN: i32 = 34;
        const SIGRTMAX: i32 = 64;
    } else if #[cfg(target_os = "freebsd")] {
        const SIGRTMIN: i32 = 65;
        const SIGRTMAX: i32 = 126;
    } else if #[cfg(target_os = "netbsd")] {
        const SIGRTMIN: i32 = 33;
        const SIGRTMAX: i32 = 63;
    } else if #[cfg(target_os = "redox")] {
        const SIGRTMIN: i32 = 27;
        const SIGRTMAX: i32 = 31;
    } else if #[cfg(any(
        target_os = "openbsd",
        target_os = "dragonfly",
        target_os = "macos",
        target_os = "ios",
        target_os = "solaris",
        target_os = "illumos",
        target_os = "hermit",
    ))] {
        const SIGRT: Option<[i32; 2]> = None;
        const SIGRTMIN: i32 = 1; // min is smaller than max so that the sloppy calculation works
        const SIGRTMAX: i32 = 0;
    }
}
#[cfg(unix)]
const _NUM_REALTIME_SIGNALS: u32 = (SIGRTMAX - SIGRTMIN + 1) as u32;
#[cfg(not(unix))]
const _NUM_REALTIME_SIGNALS: u32 = 0;

/// Whether real-time signals are supported at all.
///
/// The platforms for which `interprocess` has explicit support for real-time signals are:
/// - Linux
///     - includes Android
/// - FreeBSD
/// - NetBSD
/// - Redox
pub const REALTIME_SIGNALS_SUPPORTED: bool = NUM_REALTIME_SIGNALS != 0;
/// How many real-time signals are supported. Remember that real-time signals start from 0, so this number is higher than the highest possible real-time signal by 1.
///
/// Platform-specific values for this constant are:
/// - **Linux** and **NetBSD**: 31
/// - **FreeBSD**: 62
/// - **Redox**: 5 (does not conform with POSIX)
pub const NUM_REALTIME_SIGNALS: u32 = _NUM_REALTIME_SIGNALS;
/// Returns `true` if the specified signal is a valid real-time signal value, `false` otherwise.
#[inline(always)]
pub const fn is_valid_rtsignal(rtsignal: u32) -> bool {
    rtsignal < NUM_REALTIME_SIGNALS
}

/// The first field is the current method of handling a specific signal, the second one is the flags which were set for it.
type HandlerAndFlags = (SignalHandler, i32);
#[cfg(unix)]
lazy_static! {
    static ref HANDLERS: RwLock<IntMap<HandlerAndFlags>> = RwLock::new(IntMap::new());
}

/// Installs the specified handler for the specified standard signal, using the default values for the flags.
///
/// See [`HandlerOptions`] builder if you'd like to customize the flags.
///
/// # Example
/// ```no_run
/// use interprocess::os::unix::signal::{self, SignalType, SignalHandler};
///
/// let handler = unsafe {
///     // Since signal handlers are restricted to a specific set of system calls, creating a
///     // handler from an arbitrary function is unsafe because it might perform a system call
///     // outside the list, and there's no real way to know that at compile time with the
///     // current version of Rust. Since we're only using the write() system call here, this
///     // is safe.
///     SignalHandler::from_fn(|| {
///         println!("You pressed Ctrl-C!");
///     })
/// };
///
/// // Install our handler for the KeyboardInterrupt signal type.
/// signal::set_handler(SignalType::KeyboardInterrupt, handler);
/// ```
///
/// [`HandlerOptions`]: struct.HandlerOptions.html " "
#[inline]
pub fn set_handler(signal_type: SignalType, handler: SignalHandler) -> Result<(), SetHandlerError> {
    HandlerOptions::for_signal(signal_type)
        .set_new_handler(handler)
        .set()
}
/// Installs the specified handler for the specified unsafe signal, using the default values for the flags.
///
/// See [`HandlerOptions`] builder if you'd like to customize the flags.
///
/// # Safety
/// See the [`set_unsafe`] safety notes.
///
/// # Example
/// ```no_run
/// use interprocess::os::unix::signal::{self, SignalType, SignalHandler};
///
/// let handler = unsafe {
///     // Since signal handlers are restricted to a specific set of system calls, creating a
///     // handler from an arbitrary function is unsafe because it might perform a system call
///     // outside the list, and there's no real way to know that at compile time with the
///     // current version of Rust. Since we're only using the write() system call here, this
///     // is safe.
///     SignalHandler::from_fn(|| {
///         println!("Oh no, the motherboard broke!");
///         std::process::abort();
///     })
/// };
///
/// unsafe {
///     // Install our handler for the MemoryBusError signal type.
///     signal::set_unsafe_handler(SignalType::MemoryBusError, handler);
/// }
/// ```
///
/// [`HandlerOptions`]: struct.HandlerOptions.html " "
/// [`set_unsafe`]: struct.HandlerOptions.html#method.set_unsafe " "
#[inline]
pub unsafe fn set_unsafe_handler(signal_type: SignalType, handler: SignalHandler) -> Result<(), SetHandlerError> {
    HandlerOptions::for_signal(signal_type)
        .set_new_handler(handler)
        .set_unsafe()
}
/// Installs the specified handler for the specified real-time signal, using the default values for the flags.
///
/// See [`HandlerOptions`] builder if you'd like to customize the flags.
///
/// # Example
/// ```no_run
/// use interprocess::os::unix::signal::{self, SignalHandler};
///
/// let handler = unsafe {
///     // Since signal handlers are restricted to a specific set of system calls, creating a
///     // handler from an arbitrary function is unsafe because it might perform a system call
///     // outside the list, and there's no real way to know that at compile time with the
///     // current version of Rust. Since we're only using the write() system call here, this
///     // is safe.
///     SignalHandler::from_fn(|| {
///         println!("You sent a real-time signal!");
///     })
/// };
///
/// // Install our handler for the real-time signal 0.
/// signal::set_rthandler(0, handler);
/// ```
///
/// [`HandlerOptions`]: struct.HandlerOptions.html " "
#[inline]
pub fn set_rthandler(rtsignal: u32, handler: SignalHandler) -> Result<(), SetHandlerError> {
    HandlerOptions::for_rtsignal(rtsignal)
        .set_new_handler(handler)
        .set()
}

unsafe fn install_hook(signum: i32, hook: usize, flags: i32) -> io::Result<()> {
    let success = {
        let [mut old_handler, mut new_handler] = [zeroed::<sigaction>(); 2];
        new_handler.sa_sigaction = hook as usize;
        new_handler.sa_flags = flags;
        libc::sigaction(
            signum,
            &new_handler as *const _,
            &mut old_handler as *mut _,
        ) != -1
    };
    if success {
        Ok(())
    } else {
        Err(io::Error::last_os_error())
    }
}

/// Options for installing a signal handler.
///
/// # Example
/// ```no_run
/// use interprocess::os::unix::signal::{self, SignalType, SignalHandler};
///
/// let handler = unsafe {
///     // Since signal handlers are restricted to a specific set of system calls, creating a
///     // handler from an arbitrary function is unsafe because it might perform a system call
///     // outside the list, and there's no real way to know that at compile time with the
///     // current version of Rust. Since we're only using the write() system call here, this
///     // is safe.
///     SignalHandler::from_fn(|| {
///         println!("You pressed Ctrl-C!");
///     })
/// };
///
/// // Let's use the builder to customize the signal handler:
/// signal::HandlerOptions::for_signal(SignalType::KeyboardInterrupt)
///     .set_new_handler(handler)
///     .auto_reset_handler(true) // Let's remove the signal handler after it fires once.
///     .system_call_restart(false) // Avoid restarting system calls and let them fail with the
///                                 // Interrupted error type. There normally isn't a reason to
///                                 // do this, but for the sake of the example, let's assume
///                                 // that there is.
///     .set(); // Finalize the builder by installing the handler.
/// ```
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub struct HandlerOptions {
    signal: i32,
    /// The handler to be set up. If `None`, the handler is not changed by the call.
    pub handler: Option<SignalHandler>,
    /// For the [`ChildProcessEvent`] signal, this option *disables* receiving the signal if it was generated because the child process was suspended (using any signal which suspends a process, such as [`Suspend`] or [`ForceSuspend`]) or [resumed][`Continue`].
    ///
    /// If enabled on a signal which is not [`ChildProcessEvent`], a panic is produced in debug builds when [`set`] is called; in release builds, the flag is simply ignored.
    ///
    /// [`ChildProcessEvent`]: enum.SignalType.html#variant.ChildProcessEvent " "
    /// [`Suspend`]: enum.SignalType.html#variant.Suspend " "
    /// [`ForceSuspend`]: enum.SignalType.html#variant.ForceSuspend " "
    /// [`Continue`]: enum.SignalType.html#variant.Continue " "
    /// [`set`]: #method.set " "
    pub ignore_child_stop_events: bool,
    /// Allow the signal handler to interrupt a previous invocation of itself. If disabled, the signal handler will disable its own signal when called and restore previous state when it finishes executing. If not, an infinite amount of signals can be received on top of each other, which is likely a stack overflow risk.
    ///
    /// If enabled but the handler is [set to use the default handling method][`Default`] from the OS, a panic is produced in debug builds when [`set`] is called; in release builds, the flag is simply ignored.
    ///
    /// [`Default`]: enum.SignalHandler.html#variant.Default " "
    /// [`set`]: #method.set " "
    pub recursive_handler: bool,
    /// Automatically restart certain system calls instead of failing with the [`Interrupted`] error type. Some other system calls are not restarted with this function and may fail with [`Interrupted`] anyway. Consult your manual pages for more details.
    ///
    /// [`Interrupted`]: https://doc.rust-lang.org/std/io/enum.ErrorKind.html#variant.Interrupted " "
    pub system_call_restart: bool,
    /// Automatically reset the handler to the default handling method whenever it is executed.
    ///
    /// If enabled but the handler is [set to use the default handling method][`Default`] from the OS, a panic is produced in debug builds when [`set`] is called; in release builds, the flag is simply ignored.
    ///
    /// [`Default`]: enum.SignalHandler.html#variant.Default " "
    /// [`set`]: #method.set " "
    pub auto_reset_handler: bool,
}
impl HandlerOptions {
    /// Creates a builder for a handler for the specified signal.
    #[inline(always)]
    pub fn for_signal(signal: SignalType) -> Self {
        Self {
            signal: signal.into(),
            handler: None,
            ignore_child_stop_events: false,
            recursive_handler: false,
            system_call_restart: true,
            auto_reset_handler: false,
        }
    }
    /// Creates a builder for a handler for the specified real-time signal.
    ///
    /// # Panics
    /// Guaranteed to panic if the specified real-time signal is outside the range of real-time signals supported by the OS. See [`NUM_REALTIME_SIGNALS`].
    ///
    /// [`NUM_REALTIME_SIGNALS`]: constant.NUM_REALTIME_SIGNALS.html " "
    pub fn for_rtsignal(rtsignal: u32) -> Self {
        assert!(
            is_valid_rtsignal(rtsignal),
            "invalid real-time signal value â€” check the NUM_REALTIME_SIGNALS constant to see how \
            many are supported"
        );
        Self {
            signal: rtsignal as i32,
            handler: None,
            ignore_child_stop_events: false,
            recursive_handler: false,
            system_call_restart: true,
            auto_reset_handler: false,
        }
    }
    /// Sets the handler for the signal to the specified value. If `None`, the old value is used.
    #[inline(always)]
    pub fn set_new_handler(mut self, handler: impl Into<Option<SignalHandler>>) -> Self {
        self.handler = handler.into();
        self
    }
    /// Sets the [`ignore_child_stop_events`] flag to the specified value.
    ///
    /// [`ignore_child_stop_events`]: #structfield.ignore_child_stop_events " "
    #[inline(always)]
    pub fn ignore_child_stop_events(mut self, ignore: impl Into<bool>) -> Self {
        self.ignore_child_stop_events = ignore.into();
        self
    }
    /// Sets the [`recursive_handler`] flag to the specified value.
    ///
    /// [`recursive_handler`]: #structfield.recursive_handler " "
    #[inline(always)]
    pub fn recursive_handler(mut self, recursive: impl Into<bool>) -> Self {
        self.recursive_handler = recursive.into();
        self
    }
    /// Sets the [`system_call_restart`] flag to the specified value.
    ///
    /// [`system_call_restart`]: #structfield.system_call_restart " "
    #[inline(always)]
    pub fn system_call_restart(mut self, restart: impl Into<bool>) -> Self {
        self.system_call_restart = restart.into();
        self
    }
    /// Sets the [`auto_reset_handler`] flag to the specified value.
    ///
    /// [`auto_reset_handler`]: #structfield.auto_reset_handler " "
    #[inline(always)]
    pub fn auto_reset_handler(mut self, reset: impl Into<bool>) -> Self {
        self.auto_reset_handler = reset.into();
        self
    }
    /// Installs the signal handler.
    #[inline]
    pub fn set(self) -> Result<(), SetHandlerError> {
        if let Ok(val) = SignalType::try_from(self.signal) {
            if val.is_unsafe() {
                return Err(SetHandlerError::UnsafeSignal);
            }
        }
        unsafe {self.set_unsafe()}
    }
    
    /// Installs the signal handler, even if the signal being handled is unsafe.
    ///
    /// # Safety
    /// The handler and all code that may or may not execute afterwards must be prepared for the aftermath of what might've caused the signal. [`SegmentationFault`], for example, might be caused by hitting a stack protector as a response to a thread's stack overflow â€” in such a case, continuing the program might result in undefined behavior. The Rust runtime actually sets its own handler for `SegmentationFault` signals which converts those signals to proper shutdowns, i.e. ignoring it essentially disables stack protectors, which is unsound.
    ///
    /// [`SegmentationFault`]: enum.SignalType.html#variant.SegmentationFault " "
    pub unsafe fn set_unsafe(self) -> Result<(), SetHandlerError> {
        if let Ok(val) = SignalType::try_from(self.signal) {
            if val.is_unblockable() {
                return Err(SetHandlerError::UnblockableSignal(val));
            }
        } else if !is_valid_rtsignal(self.signal as u32) {
            return Err(SetHandlerError::RealTimeSignalOutOfBounds {
                attempted: self.signal as u32,
                max: NUM_REALTIME_SIGNALS,
            });
        }
        let handlers = HANDLERS.upgradeable_read();
        let new_flags = self.flags_as_i32();
        let mut need_to_upgrade_handle = false;
        let need_to_install_hook = if let Some(
            (existing_handler, existing_flags)
        ) = handlers.get(self.signal as u64) {
            // This signal's handler was set before â€” check if we need to install new flags or if
            // one is default and another isn't, which would mean that either that no hook was
            // installed and we have to install one or there was one installed but we need to
            // install the default hook explicitly.
            let new_handler = self.handler.unwrap_or_default();
            if new_handler != *existing_handler || new_flags != *existing_flags {
                need_to_upgrade_handle = true;
                true
            } else {
                let one_handler_is_default_and_another_isnt = (
                    new_handler.is_default() && !existing_handler.is_default()
                ) || (
                    !new_handler.is_default() && existing_handler.is_default()
                );
                   *existing_flags != new_flags
                || one_handler_is_default_and_another_isnt
            }
            
        } else {
            need_to_upgrade_handle = true;
            !self.handler.unwrap_or_default().is_default()
        };

        if need_to_install_hook {
            let hook_val = match self.handler.unwrap_or_default() {
                SignalHandler::Default => SIG_DFL,
                _ => signal_receiver as usize,
            };
            unsafe {
                // SAFETY: we're using a correct value for the hook
                install_hook(
                    self.signal,
                    hook_val,
                    new_flags,
                )?
            }
        }
        if need_to_upgrade_handle {
            let mut handlers = handlers.upgrade();
            let signal_u64 = self.signal as u64;
            handlers.remove(signal_u64);
            handlers.insert(signal_u64, (
                self.handler.unwrap_or_default(),
                new_flags,
            ));
        }
        Ok(())
    }

    #[inline]
    fn flags_as_i32(self) -> i32 {
        if self.handler.unwrap_or_default().is_default() {
            debug_assert_eq!(
                self.recursive_handler, false,
                "cannot use the recursive_handler flag with the default handling method",
            );
        }
        if self.signal != SIGCHLD {
            debug_assert_eq!(
                self.ignore_child_stop_events, false,
                "cannot use the ignore_child_stop_events flag when the signal to be handled isn't \
                ChildProcessEvent",
            );
        }
        let mut flags = 0;
        if self.auto_reset_handler {
            flags |= SA_RESETHAND;
        }
        if self.ignore_child_stop_events {
            flags |= SA_NOCLDSTOP;
        }
        if self.recursive_handler {
            flags |= SA_NODEFER;
        }
        if self.system_call_restart {
            flags |= SA_RESTART;
        }
        flags
    }
}

#[derive(Debug)]
#[cfg_attr(unix, derive(Error))]
pub enum SetHandlerError {
    /// An unsafe signal was attempted to be handled using `set` instead of `unsafe_set`.
    #[cfg_attr(
        unix,
        error("an unsafe signal was attempted to be handled using `set` instead of `unsafe_set`"),
    )]
    UnsafeSignal,
    /// The signal which was attempted to be handled is not allowed to be handled by the POSIX specification. This can either be [`ForceSuspend`] or [`Kill`].
    ///
    /// [`Kill`]: enum.SignalType.html#variant.Kill " "
    /// [`ForceSuspend`]: enum.SignalType.html#variant.ForceSuspend " "
    #[cfg_attr(
        unix,
        error("the signal {:?} cannot be handled", .0),
    )]
    UnblockableSignal (SignalType),
    /// The specified real-time signal is not available on this OS.
    #[cfg_attr(
        unix,
        error(
            "the real-time signal number {} is not available ({} is the highest possible)",
            .attempted,
            .max,
        ),
    )]
    RealTimeSignalOutOfBounds {
        attempted: u32,
        max: u32,
    },
    /// An unexpected OS error ocurred during signal handler setup.
    #[cfg_attr(
        unix,
        error("{}", .0),
    )]
    UnexpectedSystemCallFailure (#[cfg_attr(unix, from)] io::Error),
}

/// The actual hook which is passed to `sigaction` which dispatches signals according to the global handler map (the `HANDLERS` static).
extern fn signal_receiver(signum: i32) {
    let catched = panic::catch_unwind(|| {
        let handler_and_flags = {
            let handlers = HANDLERS.read();
            let val = handlers.get(signum as u64)
                .expect("unregistered signal passed by the OS to the shared receiver");
            *val
        };
        match handler_and_flags.0 {
            SignalHandler::Ignore => {},
            SignalHandler::Hook(hook) => hook.inner()(),
            SignalHandler::Default => unreachable!(
                "signal receiver was unregistered but has been called by the OS anyway"
            ),
        }
        if handler_and_flags.1 & SA_RESETHAND != 0 {
            // If the signal is set to be reset to default handling, set the record accordingly.
            let mut handlers = HANDLERS.write();
            handlers.remove(signum as u64);
            let handler_and_flags = (SignalHandler::Default, handler_and_flags.1);
            handlers.insert(signum as u64, handler_and_flags);
        }
    });
    match catched {
        Ok(..) => {},
        Err(panic_payload) => handle_panic_from_signal_receiver(panic_payload),
    }
}

fn handle_panic_from_signal_receiver(panic_payload: Box<dyn Any + Send>) -> ! {
    let panic_message = if let Some(msg) = panic_payload.downcast_ref::<&'static str>() {
        msg
    } else if let Some(msg) = panic_payload.downcast_ref::<String>() {
        &msg
    } else { "Box<dyn Any>" };
    let main_message = if let Some(name) = thread::current().name() {
        format!("thread {} panicked at '{}'", name, panic_message)
    } else {
        // TODO implement thread ID display when it gets stabilized (tracked in #67939)
        format!("unnamed thread panicked at '{}'", panic_message)
    };
    
    // We don't care abount success, since we're aborting anyway
    let mut stderr = io::stderr();
    let _ = writeln!(stderr,
        "{}", main_message,
    );
    let _ = writeln!(stderr,
        "note: backtrace and panic location information are not available because the panic was \
        intercepted in a signal handler",
    );
    
    process::abort()
}

/// A signal handling method.
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum SignalHandler {
    /// Use the default behavior specified by POSIX.
    Default,
    /// Ignore the signal whenever it is received.
    Ignore,
    /// Call a function whenever the signal is received.
    Hook(SignalHook),
}
impl SignalHandler {
    /// Returns `true` for the [`Default`] variant, `false` otherwise.
    ///
    /// [`Default`]: #variant.Default.html " "
    #[inline(always)]
    pub fn is_default(self) -> bool {
        matches!(self, Self::Default)
    }
    /// Returns `true` for the [`Ignore`] variant, `false` otherwise.
    ///
    /// [`Ignore`]: #variant.Ignore.html " "
    #[inline(always)]
    pub fn is_ignore(self) -> bool {
        matches!(self, Self::Ignore)
    }
    /// Returns `true` for the [`Hook`] variant, `false` otherwise.
    ///
    /// [`Hook`]: #variant.Hook.html " "
    #[inline(always)]
    pub fn is_hook(self) -> bool {
        matches!(self, Self::Hook(..))
    }
    /// Creates a handler which calls the specified function.
    ///
    /// # Safety
    /// The function must not perform any system calls which are not considered signal-safe. See the [module-level section on signal-safe system calls] for more.
    ///
    /// [module-level section on signal-safe system calls]: index.html#signal-safe-system-calls " "
    #[inline(always)]
    pub unsafe fn from_fn(function: fn()) -> Self {
        Self::Hook(SignalHook::from_fn(function))
    }
}
impl Default for SignalHandler {
    /// Returns [`SignalHandler::Default`].
    ///
    /// [`SignalHandler::Default`]: #variant.Default " "
    #[inline(always)]
    fn default() -> Self {
        Self::Default
    }
}
impl From<SignalHook> for SignalHandler {
    #[inline(always)]
    fn from(op: SignalHook) -> Self {
        Self::Hook(op)
    }
}
/// A function which can be used as a signal handler.
#[repr(transparent)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub struct SignalHook (fn());
impl SignalHook {
    /// Creates a hook which calls the specified function.
    ///
    /// # Safety
    /// The function must not perform any system calls which are not considered signal-safe. See the [module-level section on signal-safe system calls] for more.
    ///
    /// [module-level section on signal-safe system calls]: index.html#signal-safe-system-calls " "
    #[inline(always)]
    pub unsafe fn from_fn(function: fn()) -> Self {
        Self (function)
    }
    /// Returns the wrapped function.
    #[inline(always)]
    pub fn inner(self) -> fn() {
        self.0
    }
}
impl From<SignalHook> for fn() {
    #[inline(always)]
    fn from(op: SignalHook) -> Self {
        op.0
    }
}

/// Sends the specified signal to the specified process. If the specified signal is `None`, no signal is sent and only a privilege check is performed instead.
///
/// # Example
/// ```no_run
/// use interprocess::os::unix::signal::{self, SignalType};
/// use std::process;
///
/// // Send a Termination signal to the calling process.
/// signal::send(SignalType::Termination, process::id())?;
/// # Ok::<(), Box<dyn std::error::Error>>(())
/// ```
#[inline]
pub fn send(signal: impl Into<Option<SignalType>>, pid: impl Into<u32>) -> io::Result<()> {
    let pid = i32::try_from(pid.into())
        .unwrap_or_else(|_| panic!("process identifier out of range"));
    debug_assert_ne!(
        pid, 0,
        "to send the signal to the process group of the calling process, use send_to_group instead"
    );
    let success = unsafe {
        libc::kill(
            signal.into().map_or(0, Into::into),
            pid,
        ) != -1
    };
    if success {
        Ok(())
    } else {
        Err(io::Error::last_os_error())
    }
}
/// Sends the specified real-time signal to the specified process. If the specified signal is `None`, no signal is sent and only a privilege check is performed instead.
///
/// # Example
/// ```no_run
/// use interprocess::os::unix::signal::{self, SignalType};
/// use std::process;
///
/// // Send a real-timne signal 0 to the calling process.
/// signal::send_rt(0, process::id())?;
/// # Ok::<(), Box<dyn std::error::Error>>(())
/// ```
#[inline]
pub fn send_rt(signal: impl Into<Option<u32>>, pid: impl Into<u32>) -> io::Result<()> {
    let pid = i32::try_from(pid.into())
        .unwrap_or_else(|_| panic!("process identifier out of range"));
    debug_assert_ne!(
        pid, 0,
        "to send the signal to the process group of the calling process, use send_to_group instead"
    );
    let signal = signal.into().map_or(0, |val| {
        assert!(is_valid_rtsignal(val), "invalid real-time signal");
        val
    }) as i32;
    let success = unsafe {
        libc::kill(
            signal,
            pid,
        ) != -1
    };
    if success {
        Ok(())
    } else {
        Err(io::Error::last_os_error())
    }
}
/// Sends the specified signal to the specified process group. If the specified signal is `None`, no signal is sent and only a privilege check is performed instead.
///
/// # Example
/// ```no_run
/// use interprocess::os::unix::signal::{self, SignalType};
/// use std::process;
///
/// // Send a Termination signal to the process group of the calling process.
/// signal::send_to_group(SignalType::Termination, 0_u32)?;
/// # Ok::<(), Box<dyn std::error::Error>>(())
/// ```
pub fn send_to_group(signal: impl Into<Option<SignalType>>, pid: impl Into<u32>) -> io::Result<()> {
    #[allow(clippy::neg_multiply)] // "it's more readable to just negate"? how about no
    let pid = i32::try_from(pid.into())
        .unwrap_or_else(|_| panic!("process group identifier out of range"))
        * -1;
    let success = unsafe {
        libc::kill(
            signal.into().map_or(0, Into::into),
            pid,
        ) != -1
    };
    if success {
        Ok(())
    } else {
        Err(io::Error::last_os_error())
    }
}
/// Sends the specified real-time signal to the specified process. If the specified signal is `None`, no signal is sent and only a privilege check is performed instead.
///
/// # Example
/// ```no_run
/// use interprocess::os::unix::signal::{self, SignalType};
/// use std::process;
///
/// // Send a real-timne signal 0 to the process group of the calling process.
/// signal::send_rt(0_u32, 0_u32)?;
/// # Ok::<(), Box<dyn std::error::Error>>(())
/// ```
#[inline]
pub fn send_rt_to_group(signal: impl Into<Option<u32>>, pid: impl Into<u32>) -> io::Result<()> {
    #[allow(clippy::neg_multiply)]
    let pid = i32::try_from(pid.into())
        .unwrap_or_else(|_| panic!("process identifier out of range"))
        * -1;
    debug_assert_ne!(
        pid, 0,
        "to send the signal to the process group of the calling process, use send_to_group instead"
    );
    let signal = signal.into().map_or(0, |val| {
        assert!(is_valid_rtsignal(val), "invalid real-time signal");
        val
    }) as i32;
    let success = unsafe {
        libc::kill(
            signal,
            pid,
        ) != -1
    };
    if success {
        Ok(())
    } else {
        Err(io::Error::last_os_error())
    }
}

/// All standard signal types as defined in POSIX.1-2001.
///
/// The values can be safely and quickly converted to [`i32`]/[`u32`]. The reverse process involves safety checks, making sure that unknown signal values are never stored.
///
/// [`i32`]: https://doc.rust-lang.org/std/primitive.i32.html " "
/// [`u32`]: https://doc.rust-lang.org/std/primitive.u32.html " "
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
#[repr(i32)]
#[non_exhaustive]
pub enum SignalType {
    /// `SIGHUP` â€” lost connection to controlling terminal. Opting out of this signal is recommended if the process does not need to stop after the user who started it logs out.
    ///
    /// *Default handler: process termination.*
    Hangup = SIGHUP,
    /// `SIGINT` â€” keyboard interrupt, usually sent by pressing `Ctrl`+`C` by the terminal. This signal is typically set to be ignored if the program runs an interactive interface: GUI/TUI, interactive shell (the Python shell, for example) or any other kind of interface which runs in a loop, as opposed to a command-line invocation of the program which reads its standard input or command-line arguments, performs a task and exits. If the interactive interface is running a lengthy operation, a good idea is to temporarily re-enable the signal and abort the lengthy operation if the signal is received, then disable it again.
    ///
    /// *Default handler: process termination.*
    KeyboardInterrupt = SIGINT,
    /// `SIGQUIT` â€” request to perform a core dump and quit, usually sent by pressing `Ctrl`+`\`. This signal normally should not be overriden or masked out â€” the core dump is performed automatically by the OS.
    ///
    /// *Default handler: process termination with a core dump.*
    QuitAndDump = SIGQUIT,
    /// `SIGILL` â€” illegal or malformed instruction exception, generated by the CPU whenever such an instruction is executed. This signal normally should not be overriden or masked out, since it likely means that the executable file or the memory of the process has been corrupted and further execution is a risk of invoking negative consequences.
    ///
    /// For reasons described above, **this signal is considered unsafe** â€” handling it requires using `set_unsafe_handler`.
    ///
    /// *Default handler: process termination with a core dump.*
    IllegalInstruction = SIGILL,
    /// `SIGABRT` â€” abnormal termination requested. This signal is typically invoked by the program itself, using [`std::process::abort`] or the equivalent C function; still, like any other signal, it can be sent from outside the process.
    ///
    /// *Default handler: process termination with a core dump.*
    ///
    /// [`std::process::abort`]: https://doc.rust-lang.org/std/process/fn.abort.html " "
    Abort = SIGABRT,
    /// `SIGFPE` â€” mathematical exception. This signal is generated whenever an undefined mathematical operation is performed â€”Â mainly integer division by zero.
    ///
    /// *Default handler: process termination with a core dump.*
    MathException = SIGFPE,
    /// `SIGKILL` â€” forced termination. This signal can only be sent using the usual signal sending procedures and, unlike most other signals, cannot be masked out or handled at all. The main purpose for this signal is to stop a program which has masked out all other signals for malicious purposes or has stuck in such a state because of a bug.
    ///
    /// *Default handler: process termination, **cannot be overriden or disabled**.*
    Kill = SIGKILL,
    /// `SIGSEGV` â€” invaid memory access. This signal is issued by the OS whenever the program tries to access an invalid memory location, such as the `NULL` pointer or simply an address outside the user-mode address space as established by the OS. The only case when this signal can be received by a Rust program is if memory unsafety occurs due to misuse of unsafe code. As such, it should normally not be masked out or handled, as it likely indicates a critical bug (soundness hole), executable file corruption or process memory corruption.
    ///
    /// For reasons described above, **this signal is considered unsafe** â€” handling it requires using `set_unsafe_handler`.
    ///
    /// *Default handler: process termination with a core dump.*
    SegmentationFault = SIGSEGV,
    /// `SIGPIPE` â€” invalid access to an [unnamed pipe]. This signal is issued by the OS whenever a program attempts to write to an unnamed pipe which has no readers connected to it. If unexpected, this might mean abnormal termination of the process which the pipe was used to communicate with.
    ///
    /// *Default handler: process termination.*
    ///
    /// [unnamed pipe]: ../../../unnamed_pipe/index.html " "
    BrokenPipe = SIGPIPE,
    /// `SIGALRM` â€” "alarm clock" signal. This signal is issued by the OS when the arranged amount of real (wall clock) time expires. This clock can be set using the [`alarm`] and [`setitimer`] system calls.
    ///
    /// *Default handler: process termination.*
    ///
    /// [`alarm`]: https://www.man7.org/linux/man-pages/man2/alarm.2.html " "
    /// [`setitimer`]: https://www.man7.org/linux/man-pages/man2/setitimer.2.html " "
    AlarmClock = SIGALRM,
    /// `SIGTERM` â€” request for termination. This signal can only be sent using the usual signal sending procedures. Unlike [`KeyboardInterrupt`], this signal is not a request to break out of a lengthy operation, but rather to close the program as a whole. Signal handlers for this signal are expected to perform minimal cleanup and quick state save procedures and then exit.
    ///
    /// *Default handler: process termination.*
    ///
    /// [`KeyboardInterrupt`]: #variant.KeyboardInterrupt " "
    Termination = SIGTERM,
    /// `SIGUSR1` â€” user-defined signal 1. This signal, like [`UserSignal2`], does not have a predefined meaning and is not produced by the OS. For this reason, it is typically used for interprocess communication between two programs familiar with each other, or in language runtimes to signal certain events, such as externally activated immediate garbage collection.
    ///
    /// *Default handler: process termination.*
    ///
    /// [`UserSignal2`]: #variant.UserSignal2 " "
    UserSignal1 = SIGUSR1,
    /// `SIGUSR2` â€” user-defined signal 2. This signal is similar to [`UserSignal1`] and has the same properties, but is a distinct signal nonetheless.
    ///
    /// *Default handler: process termination.*
    ///
    /// [`UserSignal1`]: #variant.UserSignal1 " "
    UserSignal2 = SIGUSR2,
    /// `SIGCHLD` â€” child process suspended, resumed or terminated. This signal is issued by the OS whenever a child process is suspended/resumed or terminated by a signal or otherwise.
    ///
    /// *Default handler: ignore.*
    ChildProcessEvent = SIGCHLD,
    /// `SIGCONT` â€” resume the process after being suspended. This signal can be sent to a process by an external program when it wishes to resume that process after it being suspended in a stopped state.
    ///
    /// *Default handler: continue execution.*
    Continue = SIGCONT,
    /// `SIGSTOP` â€” forcefully stop a process temporarily. This signal can only be sent to a process by an external program. Unlike [`Suspend`], this signal cannot be masked out or handled, i.e. it is guaranteed to be able to temporarily stop a process from executing without [forcefully terminating it]. The process can then be restarted using [`Continue`].
    ///
    /// *Default handler: temporarily stop process, **cannot be overriden or disabled**.*
    ///
    /// [`Suspend`]: #variant.Suspend " "
    /// [forcefully terminating it]: #variant.Kill " "
    /// [`Continue`]: #variant.Continue " "
    ForceSuspend = SIGSTOP,
    /// `SIGTSTP` â€” temporarily stop a process. This signal can only be sent to a process by an external program. Unlike [`ForceSuspend`], this signal can be masked out or handled by the process which is requested to stop. The process can then be restarted using [`Continue`].
    ///
    /// *Default handler: temporarily stop process.*
    ///
    /// [`ForceSuspend`]: #variant.ForceSuspend " "
    /// [`Continue`]: #variant.Continue " "
    Suspend = SIGTSTP,
    /// `SIGTTIN` â€” attempt to read from standard input while in the background. This signal is issued by the OS whenever a process which is under [job control] tries to read from standard input but is in the background, i.e. temporarily detached from the terminal.
    ///
    /// *Default handler: temporarily stop process.*
    ///
    /// [job control]: https://en.wikipedia.org/wiki/Job_control_(Unix) " "
    TerminalInputWhileInBackground = SIGTTIN,
    /// `SIGTTOU` â€” attempt to write to standard output while in the background. This signal is issued by the OS whenever a process which is under [job control] tries to write to standard input but is in the background, i.e. temporarily detached from the terminal.
    ///
    /// *Default handler: temporarily stop process.*
    ///
    /// [job control]: https://en.wikipedia.org/wiki/Job_control_(Unix) " "
    TerminalOutputWhileInBackground = SIGTTOU,
    /// `SIGPOLL` â€” watched file descriptor event. This signal is issued by the OS when a file descriptor which has been enabled to interact with this signal has a state update.
    ///
    /// *Default handler: process termination.*
    // TODO more on this
    PollNotification = SIGPOLL,
    /// `SIGBUS` â€” [bus error]. This signal is issued by the OS when a process does one of the following:
    /// - **Tries to access an invalid physical address**. Normally, this should never happen â€” attempts to access invalid *virtual* memory are handled as [segmentation faults], and invalid phyiscal addresses are typically not present in the address space of a program in user-mode.
    /// - **Performs an incorrectly aligned memory access**. In Rust, this can only happen if unsafe code is misused to construct an incorrectly aligned pointer to a type which requires alignment which is more strict than simple one byte alignment. This is a direct sign of memory unsafety being invoked.
    /// - **Incorrect x86 segment register**. This can only be acheieved using inline assembly or FFI (calling an external function written in assembly language or with usage of C/C++ inline assembly), and only on the x86 architecture. If an invalid value is loaded into the segment registers, the CPU generates this exception. This is either a sign of a failed advanced unsafe operation or a deliberate attempt to cryptically crash the program.
    ///
    /// For reasons described above, **this signal is considered unsafe** â€” handling it requires using `set_unsafe_handler`.
    ///
    /// *Default handler: process termination with a core dump.*
    ///
    /// [bus error]: https://en.wikipedia.org/wiki/Bus_error " "
    /// [segmentation faults]: #variant.SegmentationFault " "
    MemoryBusError = SIGBUS,
    /// `SIGPROF` â€” profiler clock signal. This signal is issued by the OS when the arranged amount of CPU time expires. The time includes not only user-mode CPU time spent in the process, but also kernel-mode CPU time which the OS associates with the process. This is different from [`UserModeProfilerClock`]'s behavior, which counts only user-mode CPU time. This clock can be set using the [`setitimer`] system call.
    ///
    /// *Default handler: process termination.*
    ///
    /// [`UserModeProfilerClock`]: #variant.UserModeProfilerClock " "
    /// [`setitimer`]: https://www.man7.org/linux/man-pages/man2/setitimer.2.html " "
    ProfilerClock = SIGPROF,
    /// `SIGVTALRM` â€” user-mode profiler clock signal. This signal is issued by the OS when the arranged amount of CPU time expires. Only user-mode CPU time is counted, in contrast to `ProfilerClock`, which counts kernel-mode time associated by the system with the process as well. This clock can be set using the [`setitimer`] system call.
    ///
    /// *Default handler: process termination.*
    ///
    /// [`ProfilerClock`]: #variant.ProfilerClock " "
    /// [`setitimer`]: https://www.man7.org/linux/man-pages/man2/setitimer.2.html " "
    UserModeProfilerClock = SIGVTALRM,
    /// `SIGSYS` â€” attempt to perform an invalid system call. This signal is issued by the OS when a system call receives invalid arguments. Normally, the C library functions used to perform system calls in Rust programs do not generate this signal â€” the only way to generate it is to send it to a process explicitly, use raw system call instructions or violate [`seccomp`] rules if it is enabled.
    ///
    /// *Default handler: process termination with a core dump.*
    ///
    /// [`seccomp`]: https://en.wikipedia.org/wiki/Seccomp " "
    InvalidSystemCall = SIGSYS,
    /// `SIGTRAP` â€” software breakpoint. This signal is issued by the OS when a breakpoint instruction is executed. On x86, the instruction to do so is `int 3`. This instruction is typically inserted by debuggers and code injection utilities.
    ///
    /// *Default handler: process termination with a core dump.*
    Breakpoint = SIGTRAP,
    /// `SIGURG` â€” [out-of-band data] received on a socket. This signal is issued by the OS when a socket owned by the process receives urgent out-of-band data.
    ///
    /// *Default handler: ignore.*
    ///
    /// [out-of-band data]: https://en.wikipedia.org/wiki/Out-of-band_data " "
    OutOfBandDataAvailable = SIGURG,
    /// `SIGXCPU` â€” assigned CPU time limit for the process was exceeded. This signal is issued by the OS if a CPU time limit for the process was set, when that limit expires. If not handled quickly, the system will issue a [`Kill`] signal to shut down the process forcefully, i.e. ignoring this signal won't lead to bypassing the limit. The [`setrlimit`] system call is used to set the soft limit for this signal and the hard limit, which invokes [`Kill`].
    ///
    /// *Default handler: process termination with a core dump.*
    ///
    /// [`setrlimit`]: https://www.man7.org/linux/man-pages/man2/setrlimit.2.html " "
    /// [`Kill`]: #variant.Kill " "
    CpuTimeLimitExceeded = SIGXCPU,
    /// `SIGXFSZ` â€” assigned file size limit for the process was exceeded. This signal is issued by the OS if a limit on the size of files which are written to by the process was set, when that limit is exceeded by the process. If ignored/handled, the offending system call fails with an error regardless of the handling method. The [`setrlimit`] system call is used to set the limit.
    ///
    /// *Default handler: process termination with a core dump.*
    ///
    /// [`setrlimit`]: https://www.man7.org/linux/man-pages/man2/setrlimit.2.html " "
    FileSizeLimitExceeded = SIGXFSZ,
}
impl SignalType {
    /// Returns `true` if the value is a special signal which cannot be blocked or handled ([`Kill`] or [`ForceSuspend`]), `false` otherwise.
    ///
    /// [`Kill`]: #variant.Kill " "
    /// [`ForceSuspend`]: #variant.ForceSuspend " "
    #[inline]
    pub const fn is_unblockable(self) -> bool {
        matches!(self, Self::Kill | Self::ForceSuspend)
    }
    /// Returns `true` if the value is an unsafe signal which requires unsafe code when setting a handling method, `false` otherwise.
    #[inline]
    pub const fn is_unsafe(self) -> bool {
        matches!(self, Self::SegmentationFault | Self::MemoryBusError)
    }
}
impl From<SignalType> for i32 {
    fn from(op: SignalType) -> Self {
        unsafe {
            // SAFETY: SignalType is repr(i32)
            mem::transmute::<SignalType, i32>(op)
        }
    }
}
impl From<SignalType> for u32 {
    fn from(op: SignalType) -> Self {
        unsafe {
            // SAFETY: as above
            mem::transmute::<SignalType, u32>(op)
        }
    }
}
impl TryFrom<i32> for SignalType {
    type Error = UnknownSignalError;
    fn try_from(value: i32) -> Result<Self, Self::Error> {
        match value {
            SIGHUP    => Ok(Self::Hangup                         ),
            SIGINT    => Ok(Self::KeyboardInterrupt              ),
            SIGQUIT   => Ok(Self::QuitAndDump                    ),
            SIGILL    => Ok(Self::IllegalInstruction             ),
            SIGABRT   => Ok(Self::Abort                          ),
            SIGFPE    => Ok(Self::MathException                  ),
            SIGKILL   => Ok(Self::Kill                           ),
            SIGSEGV   => Ok(Self::SegmentationFault              ),
            SIGPIPE   => Ok(Self::BrokenPipe                     ),
            SIGALRM   => Ok(Self::AlarmClock                     ),
            SIGTERM   => Ok(Self::Termination                    ),
            SIGUSR1   => Ok(Self::UserSignal1                    ),
            SIGUSR2   => Ok(Self::UserSignal2                    ),
            SIGCHLD   => Ok(Self::ChildProcessEvent              ),
            SIGCONT   => Ok(Self::Continue                       ),
            SIGSTOP   => Ok(Self::ForceSuspend                   ),
            SIGTSTP   => Ok(Self::Suspend                        ),
            SIGTTIN   => Ok(Self::TerminalInputWhileInBackground ),
            SIGTTOU   => Ok(Self::TerminalOutputWhileInBackground),
            SIGBUS    => Ok(Self::MemoryBusError                 ),
            SIGPROF   => Ok(Self::ProfilerClock                  ),
            SIGPOLL   => Ok(Self::PollNotification               ),
            SIGSYS    => Ok(Self::InvalidSystemCall              ),
            SIGTRAP   => Ok(Self::Breakpoint                     ),
            SIGURG    => Ok(Self::OutOfBandDataAvailable         ),
            SIGVTALRM => Ok(Self::UserModeProfilerClock          ),
            SIGXCPU   => Ok(Self::CpuTimeLimitExceeded           ),
            SIGXFSZ   => Ok(Self::FileSizeLimitExceeded          ),
            _ => Err( UnknownSignalError {value} ),
        }
    }
}

/// Error type returned when a conversion from [`i32`]/[`u32`] to [`SignalType`] fails.
///
/// [`i32`]: https://doc.rust-lang.org/std/primitive.i32.html " "
/// [`u32`]: https://doc.rust-lang.org/std/primitive.u32.html " "
/// [`SignalType`]: enum.SignalType.html " "
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub struct UnknownSignalError {
    /// The unknown signal value which was encountered.
    pub value: i32,
}
impl Display for UnknownSignalError {
    #[inline]
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "unknown signal value {}", self.value)
    }
}
impl fmt::Binary for UnknownSignalError {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "unknown signal value {:b}", self.value)
    }
}
impl fmt::LowerHex for UnknownSignalError {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "unknown signal value {:x}", self.value)
    }
}
impl fmt::UpperExp for UnknownSignalError {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "unknown signal value {:X}", self.value)
    }
}
impl fmt::Octal for UnknownSignalError {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "unknown signal value {:o}", self.value)
    }
}
impl Error for UnknownSignalError {}
